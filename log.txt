2020.2.8
    -- 初始化项目
    -- 安装stylus npm install stylus stylus-loader --save-dev
    -- stylus 用于转换为css ,stylus-loader让webpack解析（理解）stylus
    -- 语法
        <style lang = "stylus" rel = "stylesheet/stylus">
            .....
        </style>

        结构化，完全通过缩进控制，不需要大括号和分号，冒号是可选的

    -- 增加组件目录
    -- 引入reset样式 http://meyerweb.com/eric/tools/css/reset/
    -- FastClick 移动端0.3秒的延迟

2020.2.9
    -- 引入路由 cnpm install vue-router --save
    -- 定义路由 msite order订单 search查询 profile个人中心
    -- 导航实现路由切换
        - 通过编程式导航实现路由的切换显示
        - 通过动态class和$route.path来实现tab样式切换
        - 通过阿里图标显示导航图标

    -- 图片资源与静态页面
    -- 封装头部组件(HeaderTop)(公共组件封装)(slot 传递标签，props传递数据)
        - slot 占位符
        - props父传子

    -- swiper库定义轮播
        - cnpm install --save swiper
        - 引入swiper的js与样式
        - 使用 new Swiper('',{})

    -- 商家列表拆分（ShopList）

    -- 登入与注册（Login）
    
    -- 添加后台

2020.2.10 
    -- 安装 axios cnpm install --save axios
    -- ajax函数封装（默认get请求） axios + promise  （api->ajax.js）
    -- 定义请求函数模块

    -- 配置代理实现跨域ajax请求

    -- 使用vuex管理状态 cnpm install --save vuex

    -- 读取当前位置：发送请求，读取状态，绑定（展示）数据
    -- 读取食品分类列表
        - 根据一维数组生成二维数组
        - 数据正常渲染，轮播bug
           原因：Swiper必须在列表显示之后才能被创建（开始是一个空数组，数据是后加载的）
           解决：通过watch（还是会延迟）
                -- 状态改变跟界面显示是两步，第一步先更新状态数据，第二次才异步更新界面
                -- 通过setTimeout延迟创建可以实现但不是最佳的
                -- 最佳 nextTick(callback),一旦界面更新就立即调用(将回调延迟到下次dom更新循环之后)
    -- 商家列表数据展示
    -- svg图片在数据未加载前显示在页面上

    -- 星星（Star）组件
       -- 星星算法
            3.2 ： 3（全星） 0（半星） 1（灰星）
            3.5 ： 3（全星） 1（半星） 1（灰星）

2020.2.11
    -- 登录动态效果
       - 登录切换
       - 手机号检查（必须输入合法的手机号才能进行获取验证码并且按钮字体高亮）
       - 倒计时效果
          - 表单中的按钮默认点击是会提交表单的  @click.prevent="getCode" （prevent禁止默认行为）
       - 切换密码显示隐藏
          - 通过定义变量为Boolean去操控样式
       - 增加消息弹框
       - 表单验证
          - 数据搜集
          - 数据验证

       - 动态显示图形验证码
       - 短信验证码 https://www.yuntongxun.com
           - 第三方对接
       - 登录
           - 更新用户中心
       - 自动登录
       - 退出登录
       - 使用 mint-ui 
           - 安装 cnpm install --save mint-ui
           - 安装按需打包 cnpm install --save-dev babel-plugin-component
              - 修改babel配置 (以下配置针对mint-ui按需打包)
              "plguins":["transform-runtime",["component",[
                  {
                      "libraryName":"mint-ui",
                      "style":true
                  }
              ]]]
          

2020.2-12  10 18 17 19 10
    -- 商家界面搭建
         - 拆分并定义路由 shop  shopGoods ShopInfo ShopRatings ShopHeader

    -- 模拟mock数据
       -- 
       -- 安装mockjs cnpm install --save mockjs
          - 编写 mockServer.js
          - 在入口文件中使用mockServer.js
          - ajax请求mock.js模拟接口
          
        -- 商家头部组件



















        -- vue-router
           - 定义路由
           - $router：路由器对象，包含一些操作路由的参数，来实现编程式导航（路由跳转）
              - 通过$route进行跳转
          - $route：代表当前路由对象，一些当前路由信息数据的容器，path/meta/query/params  
              - 通过$route中的属性动态的去添加一些类

           - <router-link to = "/xxx"></router-link> 路由页面跳转
        
        -- 动态添加class语法
           - 什么时候用对象语法？
               类名确定，只是不确定需要这个类名还是不需要
            - 底部导航动态添加class

        -- slot 占位符 (头部公共组件封装：slot 传递标签(通过slot来实现组件通信标签结构)，props传递数据)
           - 定义 <slot name = "left"></slot>
           - 使用 <div slot = "left"></div>
        
        -- swiper
           - new Swiper('',{})

        -- 模板中要写的变量有几个来源
           - props
           - data
           - 计算属性


        -- 在开发中是一个前后台分离的项目，会存在跨域的问题
           -- 解决办法：配置代理
           -- 概念：对于浏览器来说并不知道代理的存在，浏览器提交的是对当前前台应用的请求，并不知道服务器的存在
                    前台应用端口8080，后台应用端口4000，浏览器提交请求到8080，但是当我请求8080，这个也是由服务器去处理的，只不过是前台服务器
                    -- 前台应用是运行在前台服务器上的，后台应用是运行在后台服务器上的，只不过监听的端口号不一样（一旦我们通过虚拟地址进行访问能得到资源，说明就有服务器的存在）
                    -- 前台除了运行了应用以外，还运行着一个代理的代码（代理服务器），它是运行在8080上的，实际上我们发请求是在8080上，但是代理会对这个端口号进行拦截，最终转发
                      请求到4000，4000返回一个结果给代理，代理在交给前台应用
                    -- （代理的作用：就是转发请求。代理是什么：代理就是一段程序，是运行在前台服务上的，它监听的是前台的端口）

        -- vuex编码 
            -- 创建所有相关的模块 (store/index),state,mutations,actions,getters,mutation-types
            -- 设计state:从后台获取数据
            -- 实现actions
                - 定义action：async/await
                - 流程：
                       - 发送ajax请求，commit给mutation
                       -  实现mutation:给状态赋值
                       - 实现index:创建store对象
                       - main.js：配置store          

            -- 组件异步显示数据
                - 发送异步请求，将数据给state（在mounted通过$store.dispatch('actioinName') 来异步获取数据到state中）
                - 读取state中的数据（mapState(['xxx'])读取state中的数据到组件中）
                - 将数据显示到模板中

            -- 模板中显示数据的来源
                - data：自身的数据（内部改变）
                - props:外部传入的数据（外部改变）
                - computed:根据data/props，别的computed/state/getters中的属性进行计算
            
            -- 假如有路由中有多个子路由，每个子路由各有各的数据
                - 不要将多个子路由的数据全部加载出来，数据量大的化浪费带宽与内存
                - 按需加载（请求多个接口，比如当加载到该路由时再去请求对应的接口）

            -- 页面中异步数据加载都是先显示初始数据，在显示带数据的数据（初始数据可能是null（还没有数据，此时数据还在后台）,因为异步赋值也得有个过程的 ）
               - 表达式会有层级关系，比如对象中：二级a.b，三级a.b.c，假如对象二级取数据的时候已经是undefined的，那么三级肯定会取不到，取不到就会报错
               - 记住写三级表达式的时候，脑补一下会不会有什么问题
               - 解决办法：通过v-if在页面中判断一下，有数据才显示否则不显示